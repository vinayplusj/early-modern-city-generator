<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Early Modern Fantasy City Generator (Milestone 3)</title>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background: #111; color: #eee; }
    header { display: flex; gap: 12px; align-items: center; padding: 12px 14px; background: #1a1a1a; position: sticky; top: 0; }
    button, input { background: #222; color: #eee; border: 1px solid #333; padding: 8px 10px; border-radius: 8px; }
    button { cursor: pointer; }
    button:hover { background: #262626; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    canvas { display: block; width: 100vw; height: calc(100vh - 60px); }
    .label { opacity: 0.9; font-size: 14px; }
  </style>
</head>
<body>
  <header class="row">
    <button id="regen">Regenerate</button>
    <span class="label">Seed:</span>
    <input id="seed" type="number" min="1" step="1" value="1" />
    <span class="label">Bastions:</span>
    <input id="bastions" type="number" min="5" max="14" step="1" value="8" />
    <span class="label">Gates:</span>
    <input id="gates" type="number" min="2" max="6" step="1" value="3" />
  </header>

  <canvas id="c"></canvas>

  <script>
    // ---------- Utilities ----------
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    // Deterministic PRNG (Mulberry32)
    function mulberry32(seed) {
      let t = seed >>> 0;
      return function() {
        t += 0x6D2B79F5;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }

    function lerp(a, b, t) { return a + (b - a) * t; }

    function polar(cx, cy, angle, radius) {
      return { x: cx + Math.cos(angle) * radius, y: cy + Math.sin(angle) * radius };
    }

    function dist(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    function centroid(poly) {
      let a = 0, cx = 0, cy = 0;
      for (let i = 0; i < poly.length; i++) {
        const p = poly[i], q = poly[(i + 1) % poly.length];
        const cross = p.x * q.y - q.x * p.y;
        a += cross;
        cx += (p.x + q.x) * cross;
        cy += (p.y + q.y) * cross;
      }
      a *= 0.5;
      if (Math.abs(a) < 1e-6) {
        let sx = 0, sy = 0;
        for (const p of poly) { sx += p.x; sy += p.y; }
        return { x: sx / poly.length, y: sy / poly.length };
      }
      cx /= (6 * a);
      cy /= (6 * a);
      return { x: cx, y: cy };
    }

    function offsetRadial(poly, cx, cy, offset) {
      return poly.map(p => {
        const v = { x: p.x - cx, y: p.y - cy };
        const l = Math.hypot(v.x, v.y) || 1;
        const ux = v.x / l, uy = v.y / l;
        return { x: p.x + ux * offset, y: p.y + uy * offset };
      });
    }

    function pointInPoly(pt, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const a = poly[i], b = poly[j];
        const intersect =
          ((a.y > pt.y) !== (b.y > pt.y)) &&
          (pt.x < (b.x - a.x) * (pt.y - a.y) / ((b.y - a.y) || 1e-9) + a.x);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function add(a, b) { return { x: a.x + b.x, y: a.y + b.y }; }
    function sub(a, b) { return { x: a.x - b.x, y: a.y - b.y }; }
    function mul(a, s) { return { x: a.x * s, y: a.y * s }; }
    function perp(a) { return { x: -a.y, y: a.x }; }

    function normalize(v) {
      const l = Math.hypot(v.x, v.y) || 1;
      return { x: v.x / l, y: v.y / l };
    }

    function rotate(v, ang) {
      const c = Math.cos(ang), s = Math.sin(ang);
      return { x: v.x * c - v.y * s, y: v.x * s + v.y * c };
    }

    function bastionAngularOffset(bastionCount) {
      return clamp(0.22 - (bastionCount - 5) * (0.13 / 7), 0.09, 0.22);
    }

    // NEW: segment helpers (for snapping roads to ring)
    function closestPointOnSegment(p, a, b) {
      const ab = sub(b, a);
      const ap = sub(p, a);
      const ab2 = ab.x * ab.x + ab.y * ab.y || 1;
      const t = clamp((ap.x * ab.x + ap.y * ab.y) / ab2, 0, 1);
      return add(a, mul(ab, t));
    }

    function closestPointOnPolyline(p, poly) {
      let best = null;
      let bestD = Infinity;
      for (let i = 0; i < poly.length; i++) {
        const a = poly[i];
        const b = poly[(i + 1) % poly.length];
        const q = closestPointOnSegment(p, a, b);
        const d = dist(p, q);
        if (d < bestD) { bestD = d; best = q; }
      }
      return best;
    }

    // ---------- Geometry generation ----------
    function generateFootprint(rng, cx, cy, baseR, pointCount = 20) {
      const pts = [];
      const wobble = baseR * 0.22;
      const phase = rng() * Math.PI * 2;

      for (let i = 0; i < pointCount; i++) {
        const t = i / pointCount;
        const ang = t * Math.PI * 2;
        const n1 = Math.sin(ang * 2 + phase) * (0.45 + rng() * 0.25);
        const n2 = Math.sin(ang * 5 + phase * 1.7) * (0.25 + rng() * 0.2);
        const r = baseR + wobble * (n1 + n2) + wobble * (rng() - 0.5) * 0.35;
        pts.push(polar(cx, cy, ang, r));
      }

      const smooth = [];
      for (let i = 0; i < pts.length; i++) {
        const p = pts[i], q = pts[(i + 1) % pts.length];
        smooth.push({ x: lerp(p.x, q.x, 0.25), y: lerp(p.y, q.y, 0.25) });
        smooth.push({ x: lerp(p.x, q.x, 0.75), y: lerp(p.y, q.y, 0.75) });
      }

      return smooth;
    }

    function generateBastionedWall(rng, cx, cy, wallR, bastionCount) {
      const base = [];
      const rotation = rng() * Math.PI * 2;

      for (let i = 0; i < bastionCount; i++) {
        const ang = rotation + (i / bastionCount) * Math.PI * 2;
        const r = wallR * (0.96 + rng() * 0.08);
        base.push(polar(cx, cy, ang, r));
      }

      const shoulderFactor = clamp(0.30 - (bastionCount - 5) * (0.10 / 7), 0.20, 0.30);
      const bastionLen = wallR * 2.0 * shoulderFactor;
      const shoulder = wallR * 0.80 * shoulderFactor;

      const cheekAlongFrac = clamp(0.80 - (bastionCount - 5) * 0.02, 0.65, 0.80);
      const cheekOutFrac = 0.6;

      const bastions = [];

      function pushOutToMinRadial(p, curr, out, minOut) {
        const r = (p.x - curr.x) * out.x + (p.y - curr.y) * out.y;
        if (r >= minOut) return p;
        const delta = minOut - r;
        return { x: p.x + out.x * delta, y: p.y + out.y * delta };
      }

      for (let i = 0; i < base.length; i++) {
        const prev = base[(i - 1 + base.length) % base.length];
        const curr = base[i];
        const next = base[(i + 1) % base.length];

        const uIn  = normalize({ x: curr.x - prev.x, y: curr.y - prev.y });
        const uOut = normalize({ x: next.x - curr.x, y: next.y - curr.y });
        const out  = normalize({ x: curr.x - cx, y: curr.y - cy });

        const s1 = { x: curr.x - uIn.x  * shoulder, y: curr.y - uIn.y  * shoulder };
        const s2 = { x: curr.x + uOut.x * shoulder, y: curr.y + uOut.y * shoulder };

        const L = bastionLen * (0.90 + rng() * 0.25);
        const cheekAlong = L * cheekAlongFrac;

        const tip = { x: curr.x + out.x * L, y: curr.y + out.y * L };
        const cheekOut = L * cheekOutFrac;

        const leftFace0 = {
          x: curr.x + out.x * cheekOut - uIn.x * cheekAlong,
          y: curr.y + out.y * cheekOut - uIn.y * cheekAlong,
        };

        const rightFace0 = {
          x: curr.x + out.x * cheekOut + uOut.x * cheekAlong,
          y: curr.y + out.y * cheekOut + uOut.y * cheekAlong,
        };

        const minOut = wallR * 0.02;
        const leftFace  = pushOutToMinRadial(leftFace0,  curr, out, minOut);
        const rightFace = pushOutToMinRadial(rightFace0, curr, out, minOut);

        bastions.push({
          i,
          pts: [s1, leftFace, tip, rightFace, s2],
          shoulders: [s1, s2],
        });
      }

      const wall = bastions.flatMap(b => b.pts);
      return { base, wall, bastions };
    }

    function segIntersect(a, b, c, d) {
      // Proper segment intersection (including collinear overlap).
      const cross = (p, q, r) => (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x);
      const onSeg = (p, q, r) =>
        Math.min(p.x, r.x) - 1e-9 <= q.x && q.x <= Math.max(p.x, r.x) + 1e-9 &&
        Math.min(p.y, r.y) - 1e-9 <= q.y && q.y <= Math.max(p.y, r.y) + 1e-9;
    
      const d1 = cross(a, b, c);
      const d2 = cross(a, b, d);
      const d3 = cross(c, d, a);
      const d4 = cross(c, d, b);
    
      if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
          ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) return true;
    
      // Collinear cases
      if (Math.abs(d1) < 1e-9 && onSeg(a, c, b)) return true;
      if (Math.abs(d2) < 1e-9 && onSeg(a, d, b)) return true;
      if (Math.abs(d3) < 1e-9 && onSeg(c, a, d)) return true;
      if (Math.abs(d4) < 1e-9 && onSeg(c, b, d)) return true;
    
      return false;
    }
    
    function polyIntersectsPoly(A, B) {
      if (!A || !B || A.length < 3 || B.length < 3) return false;
    
      // Edge-edge intersection
      for (let i = 0; i < A.length; i++) {
        const a1 = A[i], a2 = A[(i + 1) % A.length];
        for (let j = 0; j < B.length; j++) {
          const b1 = B[j], b2 = B[(j + 1) % B.length];
          if (segIntersect(a1, a2, b1, b2)) return true;
        }
      }
    
      // Containment (one vertex inside the other polygon)
      if (pointInPoly(A[0], B)) return true;
      if (pointInPoly(B[0], A)) return true;
    
      return false;
    }

    function pickGates(rng, wallBase, gateCount, bastionCount) {
      const n = wallBase.length;
      const gates = [];
      const usedEdges = new Set();
    
      const minGap = Math.max(1, Math.floor(n / gateCount) - 1);
      const tJitter = clamp(0.16 - (bastionCount - 5) * (0.09 / 7), 0.07, 0.16);
    
      function edgeOk(e) {
        for (const j of usedEdges) {
          const d = Math.min((e - j + n) % n, (j - e + n) % n);
          if (d <= minGap) return false;
        }
        return true;
      }
    
      // Primary pass
      for (let k = 0; k < gateCount; k++) {
        let tries = 0;
        while (tries++ < 220) {
          const e = Math.floor(rng() * n);
          if (usedEdges.has(e)) continue;
          if (!edgeOk(e)) continue;
    
          usedEdges.add(e);
    
          const a = wallBase[e];
          const b = wallBase[(e + 1) % n];
    
          const sign = (e % 2 === 0) ? +1 : -1;
          const t = clamp(0.5 + sign * tJitter, 0.15, 0.85);
    
          const p = { x: lerp(a.x, b.x, t), y: lerp(a.y, b.y, t) };
          gates.push({ ...p, idx: e });
          break;
        }
      }
    
      // Fallback fill (still deterministic)
      let guard = 0;
      while (gates.length < gateCount && guard++ < 5000) {
        const e = Math.floor(rng() * n);
        if (usedEdges.has(e)) continue;
        if (!edgeOk(e)) continue;
    
        usedEdges.add(e);
    
        const a = wallBase[e];
        const b = wallBase[(e + 1) % n];
        const p = { x: lerp(a.x, b.x, 0.5), y: lerp(a.y, b.y, 0.5) };
        gates.push({ ...p, idx: e });
      }
    
      // Stable order
      gates.sort((g1, g2) => g1.idx - g2.idx);
    
      return gates;
    }


    function drawGatehouse(ctx, gate, centre, size) {
      const out = normalize({ x: gate.x - centre.x, y: gate.y - centre.y });
      const side = normalize(perp(out));

      const w = size * 1.2;
      const d = size * 0.7;

      const p = add(gate, mul(out, size * 0.35));

      const tl = add(add(p, mul(side, -w)), mul(out, -d));
      const tr = add(add(p, mul(side,  w)), mul(out, -d));
      const br = add(add(p, mul(side,  w)), mul(out,  d));
      const bl = add(add(p, mul(side, -w)), mul(out,  d));

      ctx.save();
      ctx.fillStyle = "#0f0f0f";
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.moveTo(tl.x, tl.y);
      ctx.lineTo(tr.x, tr.y);
      ctx.lineTo(br.x, br.y);
      ctx.lineTo(bl.x, bl.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      const towerR = size * 0.28;
      const towerL = add(p, mul(side, -w));
      const towerRgt = add(p, mul(side,  w));

      ctx.beginPath();
      ctx.arc(towerL.x, towerL.y, towerR, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(towerRgt.x, towerRgt.y, towerR, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      ctx.restore();
    }

    function generateRoadsToCentre(gates, centre) {
      return gates.map(g => [g, centre]);
    }

    // NEW (Milestone 3.1): secondary rings + secondary roads
    function generateSecondaryRoads(rng, gates, ring1, ring2) {
      const secondary = [];
      if (!gates || !gates.length || !ring1 || !ring2) return secondary;
    
      // Gate -> ring1, then ring1 -> ring2
      const ring1Snaps = [];
      const ring2Snaps = [];
    
      for (const g of gates) {
        const a = closestPointOnPolyline(g, ring1);
        const b = closestPointOnPolyline(a, ring2);
    
        ring1Snaps.push(a);
        ring2Snaps.push(b);
    
        secondary.push([g, a]);  // gate -> ring1
        secondary.push([a, b]);  // ring1 -> ring2
      }
    
      // Sparse cross-links on ring2 (use snapped points so it feels connected).
      // Keep it small and deterministic.
      const linkCount = clamp(Math.floor(gates.length / 2), 2, 3);
      const used = new Set();
    
      let guard = 0;
      while (used.size < linkCount && guard++ < 2000) {
        const i = Math.floor(rng() * ring2Snaps.length);
        const step = Math.max(1, Math.floor(lerp(2, Math.max(3, ring2Snaps.length - 1), rng())));
        const j = (i + step) % ring2Snaps.length;
    
        const key = i < j ? `${i}:${j}` : `${j}:${i}`;
        if (used.has(key)) continue;
    
        // Avoid very short links.
        if (dist(ring2Snaps[i], ring2Snaps[j]) < 20) continue;
    
        used.add(key);
        secondary.push([ring2Snaps[i], ring2Snaps[j]]);
      }
    
      return secondary;
    }


    function lerpPoint(a, b, t) { return { x: lerp(a.x, b.x, t), y: lerp(a.y, b.y, t) }; }

    // ---------- Rendering ----------
    function drawPoly(ctx, poly, close = true) {
      if (poly.length === 0) return;
      ctx.beginPath();
      ctx.moveTo(poly[0].x, poly[0].y);
      for (let i = 1; i < poly.length; i++) ctx.lineTo(poly[i].x, poly[i].y);
      if (close) ctx.closePath();
    }

    function drawCircle(ctx, p, r) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
    }

    function render(ctx, model) {
      const {
        footprint, outerBoundary, wall, wallBase, gates,
        centre, squareR, roads,
        ring, ring2, // NEW
        secondaryRoads, // NEW
        citadel, citCentre, avenue, ravelins,
        newTown, primaryGate, cx, cy,
        ditchOuter, ditchInner, glacisOuter
      } = model;

      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.fillStyle = "#0f0f0f";
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      ctx.fillStyle = "#151515";
      drawPoly(ctx, footprint, true);
      ctx.fill();

      if (outerBoundary && outerBoundary.length >= 3) {
        ctx.strokeStyle = "#2b2b2b";
        ctx.lineWidth = 2;
        drawPoly(ctx, outerBoundary, true);
        ctx.stroke();
      }

      if (newTown) {
        ctx.fillStyle = "#131313";
        drawPoly(ctx, newTown.poly, true);
        ctx.fill();

        ctx.save();
        ctx.globalAlpha = 0.75;
        ctx.strokeStyle = "#8f8f8f";
        ctx.lineWidth = 1.5;
        for (const s of newTown.streets) {
          ctx.beginPath();
          ctx.moveTo(s[0].x, s[0].y);
          ctx.lineTo(s[1].x, s[1].y);
          ctx.stroke();
        }
        ctx.restore();

        if (newTown.gateOut && primaryGate) {
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          ctx.moveTo(primaryGate.x, primaryGate.y);
          ctx.lineTo(newTown.mainAve[1].x, newTown.mainAve[1].y);
          ctx.stroke();
        }

        ctx.strokeStyle = "#3a3a3a";
        ctx.lineWidth = 2;
        drawPoly(ctx, newTown.poly, true);
        ctx.stroke();
      }

      if (glacisOuter) {
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = "#242424";
        ctx.lineWidth = 2;
        drawPoly(ctx, glacisOuter, true);
        ctx.stroke();
        ctx.restore();
      }

      if (ditchOuter && ditchInner) {
        ctx.save();
        ctx.globalAlpha = 0.55;

        ctx.strokeStyle = "#5a5a5a";
        ctx.lineWidth = 2;
        drawPoly(ctx, ditchOuter, true);
        ctx.stroke();

        ctx.strokeStyle = "#3f3f3f";
        ctx.lineWidth = 2;
        drawPoly(ctx, ditchInner, true);
        ctx.stroke();

        ctx.restore();
      }

      if (ravelins && ravelins.length) {
        ctx.save();
        ctx.globalAlpha = 0.65;
        ctx.strokeStyle = "#8a8a8a";
        ctx.lineWidth = 2;
        for (const rv of ravelins) {
          drawPoly(ctx, rv, true);
          ctx.stroke();
        }
        ctx.restore();
      }

      ctx.strokeStyle = "#d9d9d9";
      ctx.lineWidth = 3;
      drawPoly(ctx, wall, true);
      ctx.stroke();

      ctx.strokeStyle = "#9a9a9a";
      ctx.lineWidth = 1.5;
      drawPoly(ctx, wallBase, true);
      ctx.stroke();

      // Ring boulevard (primary)
      if (ring) {
        ctx.strokeStyle = "#bdbdbd";
        ctx.lineWidth = 2;
        drawPoly(ctx, ring, true);
        ctx.stroke();
      }

      // NEW: second ring (secondary)
      if (ring2) {
        ctx.save();
        ctx.globalAlpha = 0.65;
        ctx.strokeStyle = "#bdbdbd";
        ctx.lineWidth = 1.25;
        drawPoly(ctx, ring2, true);
        ctx.stroke();
        ctx.restore();
      }

      // NEW: secondary roads
      if (secondaryRoads && secondaryRoads.length) {
        ctx.save();
        ctx.globalAlpha = 0.70;
        ctx.strokeStyle = "#cfcfcf";
        ctx.lineWidth = 1.25;
        for (const road of secondaryRoads) {
          ctx.beginPath();
          ctx.moveTo(road[0].x, road[0].y);
          for (let i = 1; i < road.length; i++) ctx.lineTo(road[i].x, road[i].y);
          ctx.stroke();
        }
        ctx.restore();
      }

      
      if (avenue) {
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(avenue[0].x, avenue[0].y);
        for (let i = 1; i < avenue.length; i++) ctx.lineTo(avenue[i].x, avenue[i].y);
        ctx.stroke();
      }

      // Primary roads (keep thicker)
      ctx.strokeStyle = "#cfcfcf";
      ctx.lineWidth = 2;
      for (const road of roads) {
        ctx.beginPath();
        ctx.moveTo(road[0].x, road[0].y);
        for (let i = 1; i < road.length; i++) ctx.lineTo(road[i].x, road[i].y);
        ctx.stroke();
      }
      
      for (const g of gates) {
        drawGatehouse(ctx, g, { x: cx, y: cy }, squareR * 0.55);
        ctx.fillStyle = "#ffffff";
        drawCircle(ctx, g, 3.5);
        ctx.fill();
      }

      if (primaryGate) {
        ctx.fillStyle = "#ffffff";
        drawCircle(ctx, primaryGate, 6);
        ctx.fill();
      }


      if (citadel) {
        ctx.fillStyle = "#101010";
        drawPoly(ctx, citadel, true);
        ctx.fill();

        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        drawPoly(ctx, citadel, true);
        ctx.stroke();

        if (citCentre) {
          ctx.fillStyle = "#ffffff";
          drawCircle(ctx, citCentre, 2.5);
          ctx.fill();
        }
      }

      ctx.fillStyle = "#1f1f1f";
      drawCircle(ctx, centre, squareR);
      ctx.fill();
      ctx.strokeStyle = "#efefef";
      ctx.lineWidth = 2;
      drawCircle(ctx, centre, squareR);
      ctx.stroke();

      ctx.fillStyle = "#efefef";
      drawCircle(ctx, centre, 2.5);
      ctx.fill();
    }

    function generateNewTownGrid(gate, cx, cy, wallR, baseR, newTownStartOffset, scale = 1.0) {
      const out = normalize({ x: gate.x - cx, y: gate.y - cy });
      if (!isFinite(out.x) || !isFinite(out.y)) return null;
    
      const side = normalize(perp(out));
    
      const gateOut = add(gate, mul(out, newTownStartOffset));
    
      const depth = wallR * 0.80 * scale;
      const wideNear = wallR * 0.20 * scale;
      const wideFar  = wallR * 0.50 * scale;
    
      const p0 = add(gateOut, mul(side, -wideNear));
      const p1 = add(gateOut, mul(side,  wideNear));
      const p2 = add(add(gateOut, mul(out, depth * 0.55)), mul(side,  wideFar));
      const p3 = add(add(gateOut, mul(out, depth * 1.00)), mul(side,  wideFar));
      const p4 = add(add(gateOut, mul(out, depth * 1.00)), mul(side, -wideFar));
      const p5 = add(add(gateOut, mul(out, depth * 0.55)), mul(side, -wideFar));
    
      const poly = [p0, p1, p2, p3, p4, p5];
    
      const spacing = baseR * 0.085 * clamp(scale, 0.75, 1.0);
    
      // Derive grid size from geometry so density stays stable across scales
      const cols = Math.max(10, Math.floor((wideFar * 2) / spacing));
      const rows = Math.max(10, Math.floor(depth / spacing));
    
      const origin = gateOut;
    
      const points = [];
      for (let r = 0; r <= rows; r++) {
        for (let c = -Math.floor(cols / 2); c <= Math.floor(cols / 2); c++) {
          const pt = add(add(origin, mul(out, r * spacing)), mul(side, c * spacing));
          if (pointInPoly(pt, poly)) points.push({ r, c, pt });
        }
      }
    
      const key = (r, c) => `${r}|${c}`;
      const map = new Map();
      for (const p of points) map.set(key(p.r, p.c), p.pt);
    
      const streets = [];
      for (const p of points) {
        const a = p.pt;
    
        const b = map.get(key(p.r + 1, p.c));
        if (b) streets.push([a, b]);
    
        const d = map.get(key(p.r, p.c + 1));
        if (d) streets.push([a, d]);
      }
    
      const mainEnd = add(gateOut, mul(out, depth * 0.85));
      const mainAve = [gateOut, mainEnd];
    
      return { poly, streets, mainAve, gateOut };
    }

    function minDistPointToPoly(pt, poly) {
      let best = Infinity;
      for (const p of poly) {
        const d = Math.hypot(pt.x - p.x, pt.y - p.y);
        if (d < best) best = d;
      }
      return best;
    }

    function makeRavelin(gate, cx, cy, wallR, ditchWidth, glacisWidth, newTownPoly, bastionCount) {
      const out0 = normalize({ x: gate.x - cx, y: gate.y - cy });

      const theta = bastionAngularOffset(bastionCount);

      const forwardFactor = clamp(0.28 - (bastionCount - 5) * (0.10 / 7), 0.18, 0.28);
      const forward = ditchWidth + glacisWidth + wallR * forwardFactor;

      const baseW = wallR * 0.10;
      const depth = wallR * 0.12;

      function build(sign) {
        const out = rotate(out0, sign * theta);
        const side = normalize(perp(out));

        const c0 = add(gate, mul(out, forward));
        const a = add(c0, mul(side, -baseW));
        const b = add(c0, mul(side,  baseW));
        const tip = add(c0, mul(out, depth));

        return [a, tip, b];
      }

      const rvPos = build(+1);
      const rvNeg = build(-1);

      if (newTownPoly && newTownPoly.length >= 3) {
        const posIn = rvPos.some(p => pointInPoly(p, newTownPoly)) || pointInPoly(centroid(rvPos), newTownPoly);
        const negIn = rvNeg.some(p => pointInPoly(p, newTownPoly)) || pointInPoly(centroid(rvNeg), newTownPoly);

        if (posIn && !negIn) return rvNeg;
        if (negIn && !posIn) return rvPos;
        if (posIn && negIn) return null;
      }

      return (gate.idx % 2 === 0) ? rvPos : rvNeg;
    }

    function convexHull(points) {
      const pts = points.slice().sort((a, b) => (a.x - b.x) || (a.y - b.y));
      if (pts.length <= 2) return pts;

      const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

      const lower = [];
      for (const p of pts) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
          lower.pop();
        }
        lower.push(p);
      }

      const upper = [];
      for (let i = pts.length - 1; i >= 0; i--) {
        const p = pts[i];
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
          upper.pop();
        }
        upper.push(p);
      }

      upper.pop();
      lower.pop();
      return lower.concat(upper);
    }

    // ---------- Model generation ----------
    function generate(seed, bastionCount, gateCount, width, height) {
      const rng = mulberry32(seed);
    
      const cx = width * 0.5;
      const cy = height * 0.55;
      const baseR = Math.min(width, height) * 0.33;
    
      const footprint = generateFootprint(rng, cx, cy, baseR, 22);
    
      const wallR = baseR * 0.78;
    
      const { base: wallBase, wall, bastions } =
        generateBastionedWall(rng, cx, cy, wallR, bastionCount);
    
      const ditchWidth = wallR * 0.035;
      const glacisWidth = wallR * 0.08;
    
      const ditchOuter = offsetRadial(wallBase, cx, cy, ditchWidth);
      const ditchInner = offsetRadial(wallBase, cx, cy, ditchWidth * 0.35);
      const glacisOuter = offsetRadial(wallBase, cx, cy, ditchWidth + glacisWidth);
    
      const centre = centroid(footprint);
    
      const gates = pickGates(rng, wallBase, gateCount, bastionCount);
    
      // Keep a stable list of bastion polygons to treat as "keep-out".
      const bastionPolys = bastions.map(b => b.pts);
    
      // Start with the full bastioned wall.
      let wallFinal = wall;
    
      function placeNewTown() {
        const startOffset0 = (ditchWidth + glacisWidth) * 1.30;
    
        // Try gates in order, then try a few scaled variants.
        const scales = [1.0, 0.92, 0.84, 0.76];
        const offsetMul = [1.00, 1.12, 1.25]; // push it farther out if needed
    
        for (const g of gates) {
          for (const om of offsetMul) {
            for (const s of scales) {
              const nt = generateNewTownGrid(g, cx, cy, wallR, baseR, startOffset0 * om, s);
    
              // Defensive: if generator returns null or malformed poly
              if (!nt || !nt.poly || nt.poly.length < 3) continue;
    
              // Constraint 1: all vertices must be outside glacisOuter
              const outsideGlacis = nt.poly.every(p => !pointInPoly(p, glacisOuter));
              if (!outsideGlacis) continue;
    
              // Constraint 2: must not intersect any bastion polygon
              let hitsBastion = false;
              for (const bp of bastionPolys) {
                if (polyIntersectsPoly(nt.poly, bp)) { hitsBastion = true; break; }
              }
              if (hitsBastion) continue;
    
              // Constraint 3 (optional): avoid intersecting the wall polygon itself
              if (polyIntersectsPoly(nt.poly, wallFinal)) continue;
    
              return { newTown: nt, primaryGate: g };
            }
          }
        }
    
        // If nothing fits, return null.
        return { newTown: null, primaryGate: gates[0] || null };
      }
    
      // Place new town using constraints.
      const placed = placeNewTown();
      let newTown = placed.newTown;
      const primaryGate = placed.primaryGate;
    
      // Failsafe: if new town still overlaps bastions, "flatten" those bastions.
      // With the placement constraints, this should rarely trigger.
      if (newTown && newTown.poly && newTown.poly.length >= 3) {
        const bastionsFinal = bastions.map(b => {
          const hit = polyIntersectsPoly(b.pts, newTown.poly) || pointInPoly(centroid(b.pts), newTown.poly);
          return hit ? { ...b, pts: b.shoulders } : b;
        });
        wallFinal = bastionsFinal.flatMap(b => b.pts);
    
        // Optional: after flattening, you can re-check and drop newTown if it still intersects wallFinal
        if (polyIntersectsPoly(newTown.poly, wallFinal)) {
          newTown = null;
        }
      }
    
      const ravelins = gates
        .map(g => makeRavelin(g, cx, cy, wallR, ditchWidth, glacisWidth, newTown ? newTown.poly : null, bastionCount))
        .filter(Boolean);
    
      const outerBoundary = convexHull([
        ...footprint,
        ...(newTown ? newTown.poly : []),
      ]);
    
      // Milestone 3.1: two inner rings
      const ring = offsetRadial(wallBase, cx, cy, -wallR * 0.06);
      const ring2 = offsetRadial(wallBase, cx, cy, -wallR * 0.13);
    
      const citSize = baseR * 0.10;
      let citCentre = null;
      let citadel = null;
    
      for (let tries = 0; tries < 40; tries++) {
        const citAng = rng() * Math.PI * 2;
        const candidate = polar(cx, cy, citAng, wallR * 0.72);
    
        const gap = minDistPointToPoly(candidate, wallFinal);
        if (gap < citSize * 1.8) continue;
    
        citCentre = candidate;
        citadel = generateBastionedWall(rng, citCentre.x, citCentre.y, citSize, 5).wall;
        break;
      }
    
      if (!citCentre) {
        citCentre = polar(cx, cy, rng() * Math.PI * 2, wallR * 0.65);
        citadel = generateBastionedWall(rng, citCentre.x, citCentre.y, citSize, 5).wall;
      }
    
      const avenue = [centre, citCentre];
      const roads = generateRoadsToCentre(gates, centre);
    
      // Milestone 3.1: secondary roads
      const secondaryRoads = generateSecondaryRoads(rng, gates, ring, ring2);
    
      return {
        footprint,
        cx, cy,
        wallBase,
        wall: wallFinal,
        gates,
        centre,
        squareR: baseR * 0.055,
        roads,
        ring,
        ring2,
        secondaryRoads,
        citCentre,
        citadel,
        avenue,
        primaryGate,
        newTown,
        outerBoundary,
        ditchOuter,
        ditchInner,
        glacisOuter,
        ditchWidth,
        glacisWidth,
        ravelins,
        bastionPolys,
      };
    }


    // ---------- App wiring ----------
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    const seedInput = document.getElementById("seed");
    const bastionsInput = document.getElementById("bastions");
    const gatesInput = document.getElementById("gates");
    const regenBtn = document.getElementById("regen");

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor((window.innerHeight - 60) * dpr);
      canvas.style.height = (window.innerHeight - 60) + "px";
      canvas.style.width = window.innerWidth + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function draw() {
      const seed = Math.max(1, parseInt(seedInput.value || "1", 10));
      const bastions = clamp(parseInt(bastionsInput.value || "9", 10), 5, 14);
      const gates = clamp(parseInt(gatesInput.value || "3", 10), 2, 6);

      const model = generate(seed, bastions, gates, window.innerWidth, window.innerHeight - 60);
      render(ctx, model);
    }

    regenBtn.addEventListener("click", () => {
      seedInput.value = String(Math.floor(Math.random() * 1_000_000) + 1);
      draw();
    });

    seedInput.addEventListener("change", draw);
    bastionsInput.addEventListener("change", draw);
    gatesInput.addEventListener("change", draw);
    window.addEventListener("resize", () => { resizeCanvas(); draw(); });

    resizeCanvas();
    draw();
  </script>
</body>
</html>
