<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Early Modern Fantasy City Generator (Milestone 1)</title>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background: #111; color: #eee; }
    header { display: flex; gap: 12px; align-items: center; padding: 12px 14px; background: #1a1a1a; position: sticky; top: 0; }
    button, input { background: #222; color: #eee; border: 1px solid #333; padding: 8px 10px; border-radius: 8px; }
    button { cursor: pointer; }
    button:hover { background: #262626; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    canvas { display: block; width: 100vw; height: calc(100vh - 60px); }
    .label { opacity: 0.9; font-size: 14px; }
  </style>
</head>
<body>
  <header class="row">
    <button id="regen">Regenerate</button>
    <span class="label">Seed:</span>
    <input id="seed" type="number" min="1" step="1" value="1" />
    <span class="label">Bastions:</span>
    <input id="bastions" type="number" min="5" max="12" step="1" value="8" />
    <span class="label">Gates:</span>
    <input id="gates" type="number" min="2" max="6" step="1" value="3" />
  </header>

  <canvas id="c"></canvas>

  <script>
    // ---------- Utilities ----------
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    // Deterministic PRNG (Mulberry32)
    function mulberry32(seed) {
      let t = seed >>> 0;
      return function() {
        t += 0x6D2B79F5;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }

    function lerp(a, b, t) { return a + (b - a) * t; }

    function polar(cx, cy, angle, radius) {
      return { x: cx + Math.cos(angle) * radius, y: cy + Math.sin(angle) * radius };
    }

    function dist(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    function centroid(poly) {
      // Polygon centroid (area-weighted). Falls back to average if degenerate.
      let a = 0, cx = 0, cy = 0;
      for (let i = 0; i < poly.length; i++) {
        const p = poly[i], q = poly[(i + 1) % poly.length];
        const cross = p.x * q.y - q.x * p.y;
        a += cross;
        cx += (p.x + q.x) * cross;
        cy += (p.y + q.y) * cross;
      }
      a *= 0.5;
      if (Math.abs(a) < 1e-6) {
        let sx = 0, sy = 0;
        for (const p of poly) { sx += p.x; sy += p.y; }
        return { x: sx / poly.length, y: sy / poly.length };
      }
      cx /= (6 * a);
      cy /= (6 * a);
      return { x: cx, y: cy };
    }

    function offsetRadial(poly, cx, cy, offset) {
      // Moves each vertex inward (negative) or outward (positive) along the centre radial.
      return poly.map(p => {
        const v = { x: p.x - cx, y: p.y - cy };
        const l = Math.hypot(v.x, v.y) || 1;
        const ux = v.x / l, uy = v.y / l;
        return { x: p.x + ux * offset, y: p.y + uy * offset };
      });
    }
    
    function pointInPoly(pt, poly) {
      // Ray casting algorithm
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const a = poly[i], b = poly[j];
        const intersect =
          ((a.y > pt.y) !== (b.y > pt.y)) &&
          (pt.x < (b.x - a.x) * (pt.y - a.y) / ((b.y - a.y) || 1e-9) + a.x);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    
    function add(a, b) { return { x: a.x + b.x, y: a.y + b.y }; }
    function sub(a, b) { return { x: a.x - b.x, y: a.y - b.y }; }
    function mul(a, s) { return { x: a.x * s, y: a.y * s }; }
    function perp(a) { return { x: -a.y, y: a.x }; }

    function normalize(v) {
      const l = Math.hypot(v.x, v.y) || 1;
      return { x: v.x / l, y: v.y / l };
    }
    
    function regularPolygon(cx, cy, r, sides, rotation = 0) {
      const pts = [];
      for (let i = 0; i < sides; i++) {
        const ang = rotation + (i / sides) * Math.PI * 2;
        pts.push(polar(cx, cy, ang, r));
      }
      return pts;
    }

    
    // ---------- Geometry generation ----------
    function generateFootprint(rng, cx, cy, baseR, pointCount = 20) {
      // Make a blobby polygon by sampling radius with noise, then smoothing once.
      const pts = [];
      const wobble = baseR * 0.22;
      const phase = rng() * Math.PI * 2;

      for (let i = 0; i < pointCount; i++) {
        const t = i / pointCount;
        const ang = t * Math.PI * 2;
        // Two-frequency wobble to feel less uniform
        const n1 = Math.sin(ang * 2 + phase) * (0.45 + rng() * 0.25);
        const n2 = Math.sin(ang * 5 + phase * 1.7) * (0.25 + rng() * 0.2);
        const r = baseR + wobble * (n1 + n2) + wobble * (rng() - 0.5) * 0.35;
        pts.push(polar(cx, cy, ang, r));
      }

      // Simple smoothing pass (Chaikin-ish lite)
      const smooth = [];
      for (let i = 0; i < pts.length; i++) {
        const p = pts[i], q = pts[(i + 1) % pts.length];
        smooth.push({ x: lerp(p.x, q.x, 0.25), y: lerp(p.y, q.y, 0.25) });
        smooth.push({ x: lerp(p.x, q.x, 0.75), y: lerp(p.y, q.y, 0.75) });
      }

      return smooth;
    }

    function generateBastionedWall(rng, cx, cy, wallR, bastionCount) {
      // Base regular polygon
      const base = [];
      const rotation = rng() * Math.PI * 2;
    
      for (let i = 0; i < bastionCount; i++) {
        const ang = rotation + (i / bastionCount) * Math.PI * 2;
        const r = wallR * (0.96 + rng() * 0.08);
        base.push(polar(cx, cy, ang, r));
      }
    
      // Pentangular bastions
      const wall = [];
    
      // Bigger bastions, slightly tighter shoulders
      const bastionLen = wallR * 0.30;   // was ~0.22
      const shoulder = wallR * 0.085;    // was ~0.10
    
      // Controls the “pentangular” look
      const faceOutFrac = 0.58;          // how far faces push outward (fraction of bastionLen)
      const faceSideFrac = 0.42;         // how wide the faces spread sideways (fraction of bastionLen)
    
      for (let i = 0; i < base.length; i++) {
        const prev = base[(i - 1 + base.length) % base.length];
        const curr = base[i];
        const next = base[(i + 1) % base.length];
    
        // Edge unit vectors
        const v1 = { x: curr.x - prev.x, y: curr.y - prev.y };
        const v2 = { x: next.x - curr.x, y: next.y - curr.y };
        const l1 = Math.hypot(v1.x, v1.y) || 1;
        const l2 = Math.hypot(v2.x, v2.y) || 1;
        const u1 = { x: v1.x / l1, y: v1.y / l1 };
        const u2 = { x: v2.x / l2, y: v2.y / l2 };
    
        // Shoulder points along the base ring edges
        const s1 = { x: curr.x - u1.x * shoulder, y: curr.y - u1.y * shoulder };
        const s2 = { x: curr.x + u2.x * shoulder, y: curr.y + u2.y * shoulder };
    
        // Outward direction from city centre
        const fromC = { x: curr.x - cx, y: curr.y - cy };
        const lc = Math.hypot(fromC.x, fromC.y) || 1;
        const out = { x: fromC.x / lc, y: fromC.y / lc };
    
        // Perpendicular direction for widening the bastion faces
        const side = { x: -out.y, y: out.x };
    
        const lenJitter = (0.92 + rng() * 0.22);
        const L = bastionLen * lenJitter;
    
        // Tip (furthest point)
        const tip = {
          x: curr.x + out.x * L,
          y: curr.y + out.y * L,
        };
    
        // Two “face” points to create a pentangular look
        const faceOut = L * faceOutFrac;
        const faceSide = L * faceSideFrac;
    
        const leftFace = {
          x: curr.x + out.x * faceOut + side.x * faceSide,
          y: curr.y + out.y * faceOut + side.y * faceSide,
        };
    
        const rightFace = {
          x: curr.x + out.x * faceOut - side.x * faceSide,
          y: curr.y + out.y * faceOut - side.y * faceSide,
        };
    
        // Build pentangular bastion: 5 points
        wall.push(s1, leftFace, tip, rightFace, s2);
      }
    
      return { base, wall };
    }


    function pickGates(rng, wallBase, gateCount) {
      // Choose gate vertices spaced out around the ring.
      const n = wallBase.length;
      const gates = [];
      const used = new Set();
      const minGap = Math.floor(n / gateCount) - 1;

      for (let k = 0; k < gateCount; k++) {
        let tries = 0;
        while (tries++ < 200) {
          const idx = Math.floor(rng() * n);
          if (used.has(idx)) continue;

          // Enforce spacing
          let ok = true;
          for (const j of used) {
            const d = Math.min((idx - j + n) % n, (j - idx + n) % n);
            if (d <= minGap) { ok = false; break; }
          }
          if (!ok) continue;

          used.add(idx);
          gates.push({ ...wallBase[idx], idx });
          break;
        }
      }

      // If we failed to place enough due to strict spacing, relax.
      while (gates.length < gateCount) {
        const idx = Math.floor(rng() * n);
        if (!used.has(idx)) {
          used.add(idx);
          gates.push({ ...wallBase[idx], idx });
        }
      }

      return gates;
    }

    function drawGatehouse(ctx, gate, centre, size) {
      const out = normalize({ x: gate.x - centre.x, y: gate.y - centre.y });
      const side = normalize(perp(out));
    
      const w = size * 1.2;  // width across the wall
      const d = size * 0.7;  // depth outward
    
      // Place gatehouse slightly outward from the wall line
      const p = add(gate, mul(out, size * 0.35));
    
      // Rectangle corners (oriented)
      const tl = add(add(p, mul(side, -w)), mul(out, -d));
      const tr = add(add(p, mul(side,  w)), mul(out, -d));
      const br = add(add(p, mul(side,  w)), mul(out,  d));
      const bl = add(add(p, mul(side, -w)), mul(out,  d));
    
      // Main body
      ctx.save();
      ctx.fillStyle = "#0f0f0f";
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2;
    
      ctx.beginPath();
      ctx.moveTo(tl.x, tl.y);
      ctx.lineTo(tr.x, tr.y);
      ctx.lineTo(br.x, br.y);
      ctx.lineTo(bl.x, bl.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    
      // Two small towers (circles) on the corners nearest the wall
      const towerR = size * 0.28;
      const towerL = add(p, mul(side, -w));
      const towerRgt = add(p, mul(side,  w));
    
      ctx.beginPath();
      ctx.arc(towerL.x, towerL.y, towerR, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
    
      ctx.beginPath();
      ctx.arc(towerRgt.x, towerRgt.y, towerR, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
    
      ctx.restore();
    }


    function generateRoadsToCentre(gates, centre) {
      // Primary roads as straight polylines for now.
      return gates.map(g => [g, centre]);
    }

    // ---------- Rendering ----------
    function drawPoly(ctx, poly, close = true) {
      if (poly.length === 0) return;
      ctx.beginPath();
      ctx.moveTo(poly[0].x, poly[0].y);
      for (let i = 1; i < poly.length; i++) ctx.lineTo(poly[i].x, poly[i].y);
      if (close) ctx.closePath();
    }

    function drawCircle(ctx, p, r) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
    }

    function render(ctx, model) {
      const {
        footprint, outerBoundary, wall, wallBase, gates,
        centre, squareR, roads, ditchOuter, ditchInner, glacisOuter,
        ring, citadel, citCentre, avenue, ravelins,
        newTown, primaryGate
      } = model;

      // Background
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.fillStyle = "#0f0f0f";
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      // Footprint fill
      ctx.fillStyle = "#151515";
      drawPoly(ctx, footprint, true);
      ctx.fill();

      // Footprint outline
      // Outer boundary outline (includes New Town)
      if (outerBoundary && outerBoundary.length >= 3) {
        ctx.strokeStyle = "#2b2b2b";
        ctx.lineWidth = 2;
        drawPoly(ctx, outerBoundary, true);
        ctx.stroke();
      }
      
      // New Town area (planned expansion) – draw first (behind the military belts)
      if (newTown) {
        // Fill zone
        ctx.fillStyle = "#131313";
        drawPoly(ctx, newTown.poly, true);
        ctx.fill();
      
        // Grid streets
        ctx.save();
        ctx.globalAlpha = 0.75;
        ctx.strokeStyle = "#8f8f8f";
        ctx.lineWidth = 1.5;
        for (const s of newTown.streets) {
          ctx.beginPath();
          ctx.moveTo(s[0].x, s[0].y);
          ctx.lineTo(s[1].x, s[1].y);
          ctx.stroke();
        }
        ctx.restore();
      
        // Main connection (gate -> deep into New Town)
        if (newTown.gateOut && primaryGate) {
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          ctx.moveTo(primaryGate.x, primaryGate.y);
          ctx.lineTo(newTown.mainAve[1].x, newTown.mainAve[1].y);
          ctx.stroke();
        }
      
        // Outline
        ctx.strokeStyle = "#3a3a3a";
        ctx.lineWidth = 2;
        drawPoly(ctx, newTown.poly, true);
        ctx.stroke();
      }
      
      // Glacis belt (no-build zone) – above New Town
      if (glacisOuter) {
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = "#242424";
        ctx.lineWidth = 2;
        drawPoly(ctx, glacisOuter, true);
        ctx.stroke();
        ctx.restore();
      }
      
      // Ditch ring – above glacis
      if (ditchOuter && ditchInner) {
        ctx.save();
        ctx.globalAlpha = 0.55;
      
        ctx.strokeStyle = "#5a5a5a";
        ctx.lineWidth = 2;
        drawPoly(ctx, ditchOuter, true);
        ctx.stroke();
      
        ctx.strokeStyle = "#3f3f3f";
        ctx.lineWidth = 2;
        drawPoly(ctx, ditchInner, true);
        ctx.stroke();
      
        ctx.restore();
      }
      
      // Ravelins (outworks) – above ditch
      if (ravelins && ravelins.length) {
        ctx.save();
        ctx.globalAlpha = 0.65;
        ctx.strokeStyle = "#8a8a8a";
        ctx.lineWidth = 2;
        for (const rv of ravelins) {
          drawPoly(ctx, rv, true);
          ctx.stroke();
        }
        ctx.restore();
      }


      // Bastioned wall
      ctx.strokeStyle = "#d9d9d9";
      ctx.lineWidth = 3;
      drawPoly(ctx, wall, true);
      ctx.stroke();

      // Inner base ring (helps readability)
      ctx.strokeStyle = "#9a9a9a";
      ctx.lineWidth = 1.5;
      drawPoly(ctx, wallBase, true);
      ctx.stroke();

      // Ring boulevard
      if (ring) {
        ctx.strokeStyle = "#bdbdbd";
        ctx.lineWidth = 2;
        drawPoly(ctx, ring, true);
        ctx.stroke();
      }

      // Gates (small breaks/markers)
      for (const g of gates) {
        drawGatehouse(ctx, g, centre, squareR * 0.55);
        ctx.fillStyle = "#ffffff";
        drawCircle(ctx, g, 4);
        ctx.fill();


      if (primaryGate) {
        ctx.fillStyle = "#ffffff";
        drawCircle(ctx, primaryGate, 6);
        ctx.fill();
      }

      // Primary avenue (square -> citadel)
      if (avenue) {
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(avenue[0].x, avenue[0].y);
        for (let i = 1; i < avenue.length; i++) ctx.lineTo(avenue[i].x, avenue[i].y);
        ctx.stroke();
      }
      
      // Roads
      ctx.strokeStyle = "#cfcfcf";
      ctx.lineWidth = 2;
      for (const road of roads) {
        ctx.beginPath();
        ctx.moveTo(road[0].x, road[0].y);
        for (let i = 1; i < road.length; i++) ctx.lineTo(road[i].x, road[i].y);
        ctx.stroke();
      }

      // Citadel
      if (citadel) {
        ctx.fillStyle = "#101010";
        drawPoly(ctx, citadel, true);
        ctx.fill();
      
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        drawPoly(ctx, citadel, true);
        ctx.stroke();
      
        if (citCentre) {
          ctx.fillStyle = "#ffffff";
          drawCircle(ctx, citCentre, 2.5);
          ctx.fill();
        }
      }
      
      // Central square
      ctx.fillStyle = "#1f1f1f";
      drawCircle(ctx, centre, squareR);
      ctx.fill();
      ctx.strokeStyle = "#efefef";
      ctx.lineWidth = 2;
      drawCircle(ctx, centre, squareR);
      ctx.stroke();

      // Centre marker
      ctx.fillStyle = "#efefef";
      drawCircle(ctx, centre, 2.5);
      ctx.fill();
    }
    
    function generateNewTownGrid(gate, cx, cy, wallR, baseR, newTownStartOffset) {
      // Direction outward from centre through the gate
      const out = normalize({ x: gate.x - cx, y: gate.y - cy });
      const side = normalize(perp(out));
    
      // Start outside the wall so the expansion is attached to the gate properly
      const gateOut = add(gate, mul(out, newTownStartOffset));
    
      // New Town footprint as a 6-point polygon (a tapered expansion)
      const depth = wallR * 0.75;
      const wideNear = wallR * 0.28;
      const wideFar = wallR * 0.40;
    
      const p0 = add(gateOut, mul(side, -wideNear));
      const p1 = add(gateOut, mul(side,  wideNear));
      const p2 = add(add(gateOut, mul(out, depth * 0.55)), mul(side,  wideFar));
      const p3 = add(add(gateOut, mul(out, depth * 1.00)), mul(side,  wideFar));
      const p4 = add(add(gateOut, mul(out, depth * 1.00)), mul(side, -wideFar));
      const p5 = add(add(gateOut, mul(out, depth * 0.55)), mul(side, -wideFar));
    
      const poly = [p0, p1, p2, p3, p4, p5];
    
      // Grid parameters
      const spacing = baseR * 0.085;
      const cols = 18;
      const rows = 18;
    
      // Grid origin starts at the outside edge of the gate apron
      const origin = gateOut;
    
      // Build grid points in a local coordinate system (out, side)
      const points = [];
      for (let r = 0; r <= rows; r++) {
        for (let c = -Math.floor(cols / 2); c <= Math.floor(cols / 2); c++) {
          const pt = add(add(origin, mul(out, r * spacing)), mul(side, c * spacing));
          if (pointInPoly(pt, poly)) points.push({ r, c, pt });
        }
      }
    
      // Index points for adjacency lookup
      const key = (r, c) => `${r}|${c}`;
      const map = new Map();
      for (const p of points) map.set(key(p.r, p.c), p.pt);
    
      // Create streets as edges between adjacent grid points
      const streets = [];
      for (const p of points) {
        const a = p.pt;
    
        // Connect forward (out direction)
        const b = map.get(key(p.r + 1, p.c));
        if (b) streets.push([a, b]);
    
        // Connect sideways (side direction)
        const d = map.get(key(p.r, p.c + 1));
        if (d) streets.push([a, d]);
      }
    
      // Main avenue from just outside the gate into the new town
      const mainEnd = add(gateOut, mul(out, depth * 0.85));
      const mainAve = [gateOut, mainEnd];
    
      return { poly, streets, mainAve, gateOut };
    }

    function minDistPointToPoly(pt, poly) {
      let best = Infinity;
      for (const p of poly) {
        const d = Math.hypot(pt.x - p.x, pt.y - p.y);
        if (d < best) best = d;
      }
      return best;
    }

    function makeRavelin(gate, cx, cy, wallR, ditchWidth, glacisWidth) {
      const out = normalize({ x: gate.x - cx, y: gate.y - cy });
      const side = normalize(perp(out));
    
      // Do not shrink: keep the larger size
      const baseW = wallR * 0.10;
      const depth = wallR * 0.12;
    
      // Push farther out beyond ditch + glacis
      // Add an extra buffer so it cannot overlap the wall, even with big bastions
      const forward = ditchWidth + glacisWidth + wallR * 0.22;
    
      const centre = add(gate, mul(out, forward));
    
      const a = add(centre, mul(side, -baseW));
      const b = add(centre, mul(side,  baseW));
      const c = add(centre, mul(out,   depth));
    
      return [a, c, b];
    }


    // Add a convex hull
    function convexHull(points) {
      // Monotonic chain convex hull
      const pts = points.slice().sort((a, b) => (a.x - b.x) || (a.y - b.y));
      if (pts.length <= 2) return pts;
    
      const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
    
      const lower = [];
      for (const p of pts) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
          lower.pop();
        }
        lower.push(p);
      }
    
      const upper = [];
      for (let i = pts.length - 1; i >= 0; i--) {
        const p = pts[i];
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
          upper.pop();
        }
        upper.push(p);
      }
    
      upper.pop();
      lower.pop();
      return lower.concat(upper);
    }

    
    // ---------- Model generation ----------
    function generate(seed, bastionCount, gateCount, width, height) {
      const rng = mulberry32(seed);
    
      const cx = width * 0.5;
      const cy = height * 0.55; // slightly lower to leave UI breathing room
      const baseR = Math.min(width, height) * 0.33;
    
      const footprint = generateFootprint(rng, cx, cy, baseR, 22);
    
      // Wall ring radius smaller than footprint so it stays inside
      const wallR = baseR * 0.78;
      const { base: wallBase, wall } = generateBastionedWall(rng, cx, cy, wallR, bastionCount);
    
      // --- Ditch + glacis (use wallBase for clean offsets) ---
      const ditchWidth = wallR * 0.035;
      const glacisWidth = wallR * 0.08;
    
      const ditchOuter = offsetRadial(wallBase, cx, cy, ditchWidth);
      const ditchInner = offsetRadial(wallBase, cx, cy, ditchWidth * 0.35);
      const glacisOuter = offsetRadial(wallBase, cx, cy, ditchWidth + glacisWidth);
    
      const centre = centroid(footprint);
    
      const gates = pickGates(rng, wallBase, gateCount);
    
      // Pick the primary gate (first gate) for the New Town expansion
      const primaryGate = gates[0];
    
      // Ravelins (outworks)
      const ravelins = gates.map(g => makeRavelin(g, cx, cy, wallR, ditchWidth, glacisWidth));
    
      // New Town starts beyond the glacis
      const newTownStartOffset = (ditchWidth + glacisWidth) * 1.05;
      const newTown = generateNewTownGrid(primaryGate, cx, cy, wallR, baseR, newTownStartOffset);
    
      // Outer boundary that includes both core footprint and New Town
      const outerBoundary = convexHull([
        ...footprint,
        ...(newTown ? newTown.poly : []),
      ]);
    
      // Ring boulevard just inside the walls (use wallBase for cleaner shape)
      const ring = offsetRadial(wallBase, cx, cy, -wallR * 0.06);
    
      // --- Citadel placement with collision avoidance against the main wall ---
      const citSize = baseR * 0.10;
      let citCentre = null;
      let citadel = null;
    
      for (let tries = 0; tries < 40; tries++) {
        const citAng = rng() * Math.PI * 2;
        const candidate = polar(cx, cy, citAng, wallR * 0.72);
    
        const gap = minDistPointToPoly(candidate, wall);
        if (gap < citSize * 1.8) continue;
    
        citCentre = candidate;
        citadel = generateBastionedWall(rng, citCentre.x, citCentre.y, citSize, 5).wall;
        break;
      }
    
      if (!citCentre) {
        citCentre = polar(cx, cy, rng() * Math.PI * 2, wallR * 0.65);
        citadel = generateBastionedWall(rng, citCentre.x, citCentre.y, citSize, 5).wall;
      }
    
      // Avenue: straight line from square to citadel centre
      const avenue = [centre, citCentre];
    
      const roads = generateRoadsToCentre(gates, centre);
    
      return {
        footprint,
        wallBase,
        wall,
        gates,
        centre,
        squareR: baseR * 0.055,
        roads,
        ring,
        citCentre,
        citadel,
        avenue,
        primaryGate,
        newTown,
        outerBoundary,
        ditchOuter,
        ditchInner,
        glacisOuter,
        ditchWidth,
        glacisWidth,
        ravelins,
      };
    }


    // ---------- App wiring ----------
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    const seedInput = document.getElementById("seed");
    const bastionsInput = document.getElementById("bastions");
    const gatesInput = document.getElementById("gates");
    const regenBtn = document.getElementById("regen");

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor((window.innerHeight - 60) * dpr);
      canvas.style.height = (window.innerHeight - 60) + "px";
      canvas.style.width = window.innerWidth + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function draw() {
      const seed = Math.max(1, parseInt(seedInput.value || "1", 10));
      const bastions = clamp(parseInt(bastionsInput.value || "8", 10), 5, 12);
      const gates = clamp(parseInt(gatesInput.value || "3", 10), 2, 6);

      const model = generate(seed, bastions, gates, window.innerWidth, window.innerHeight - 60);
      render(ctx, model);
    }

    regenBtn.addEventListener("click", () => {
      seedInput.value = String(Math.floor(Math.random() * 1_000_000) + 1);
      draw();
    });

    seedInput.addEventListener("change", draw);
    bastionsInput.addEventListener("change", draw);
    gatesInput.addEventListener("change", draw);
    window.addEventListener("resize", () => { resizeCanvas(); draw(); });

    resizeCanvas();
    draw();
  </script>
</body>
</html>
